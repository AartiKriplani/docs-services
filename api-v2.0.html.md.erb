---
title: Service Broker API v2.0
owner: Services API
---

<strong><%= modified_date %></strong>

## <a id='changelog'></a>Document Changelog ##

[v2 API Change Log](v2-api-changelog.html)

<%= partial "version_table.html" %>

## <a id='changes'></a>Changes ##

### <a id='change-policy'></a>Change Policy ###

* Existing endpoints and fields will not be removed or renamed.
* New optional endpoints, or new HTTP methods for existing endpoints, may be added to enable support for new features.
* New fields may be added to existing request/response messages. These fields must be optional, and should be ignored by clients and servers that do not understand them.

### <a id='api-changes-since-v1'></a>Changes Since v1 ###

The key changes from v1 to v2 of the Services API are:

* Terminology change --- In the v2 Services API, what used to be called a service gateway is referred to as a service broker.
* Unidirectional RESTful HTTP messages --- The Cloud Controller initiates all communication with brokers, so a broker can run standalone.
* Easier catalog management --- This functionality is improved, and moved from the broker to the Cloud Controller.
* Consistent naming --- API endpoints and fields are consistently named.
* Orphan mitigation --- Orphan service instances and bindings are prevented to the extent possible, and automatically removed, when necessary.


## <a id='api-overview'></a>API Overview ##

The Service Broker API defines an HTTP interface between the services marketplace of a platform and service brokers.

The service broker is the component of the service that implements the Service Broker API, for which a platform's marketplace is a client. Service brokers are responsible for advertising a catalog of service offerings and service plans to the marketplace, and acting on requests from the marketplace for provisioning, binding, unbinding, and deprovisioning.

In general, provisioning reserves a resource on a service; we call this reserved resource a service instance. What a service instance represents can vary by service. Examples include a single database on a multi-tenant server, a dedicated cluster, or an account on a web application.

What a binding represents may also vary by service. In general creation of a binding either generates credentials necessary for accessing the resource or provides the service instance with information for a configuration change.

A platform marketplace may expose services from one or many service brokers, and an individual service broker may support one or many platform marketplaces using different URL prefixes and credentials.

## <a id='api-version-header'></a>API Version Header ##


Requests from the platform to the service broker must contain a header that declares the version number of the Service Broker API that the marketplace will use:

`X-Broker-Api-Version: 2.0`

The version numbers are in the format `MAJOR.MINOR`, using semantic versioning such that 2.0 comes before 2.1.

This header allows brokers to reject requests from marketplaces for versions they do not support. While minor API revisions will always be additive, it is possible that brokers depend on a feature from a newer version of the API that is supported by the platform. In this scenario the broker may reject the request with `412 Precondition Failed` and provide a message that informs the operator of the required API version.


## <a id='authentication'></a>Authentication ##

The marketplace must authenticate with the service broker using HTTP
basic authentication (the `Authorization:` header) on every request. The broker is responsible for validating the username and password and returning a `401 Unauthorized` message if credentials are invalid. It is recommended that brokers support secure communication from platform marketplaces over TLS.

## <a id='catalog-mgmt'></a>Catalog Management ##

The first endpoint that a broker must implement is the service catalog. Cloud Controller will initially fetch this endpoint from all brokers and make adjustments to the user-facing service catalog stored in the Cloud Controller database. If the catalog fails to initially load or validate, Cloud Controller will not allow the operator to add the new broker, and should give a meaningful error message. Cloud Controller will also update the catalog whenever a broker is updated, so you can use `update-service-broker` with no changes to force a catalog refresh.

When Cloud Controller fetches a catalog from a broker, it will compare the broker's id for services and plans with the `unique_id` values for services and plan in the  Cloud Controller database. If a service or plan in the broker catalog has an id which is not present amongst the `unique_id` values in the database, a new record will be added to the database. If services or plans in the database are found with `unique_id`s that match the broker catalog's id, Cloud Controller will update update the records to match the brokerâ€™s catalog.

If the database has plans which are not found in the broker catalog, and there are no associated service instances, Cloud Controller will remove these plans from the database. If there are provisioned instances, the plan will be marked "inactive" and will no longer be visible in the marketplace catalog or be provisionable. Cloud Controller will then delete services that do not have associated plans from the database.

### Request ###

##### Route #####
`GET /v2/catalog`

##### cURL #####
<pre class="terminal">
 $ curl -H "X-Broker-API-Version: 2.0" http://username:password@broker-url/v2/catalog
</pre>

### Response ###

<table border="1" class="nice">
<thead>
<tr>
  <th>Status Code</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td>200 OK</td>
  <td>The expected response body is below</td>
</tr>
</tbody>
</table>

##### Body #####

<table border="1" class="nice">

<thead>
<tr>
  <th>Response field</th>
  <th>Type</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td>services*</td>
  <td>array-of-objects</td>
  <td>Schema of service objects defined below:</td>
</tr>
<tr>
  <td>&nbsp;&nbsp;&nbsp;id*</td>
  <td>string</td>
  <td>An identifier used to correlate this service in future requests to the catalog. This must be unique within Cloud Foundry, using a GUID is recommended. </td>
</tr>
<tr>
  <td>&nbsp;&nbsp;&nbsp;name*</td>
  <td>string</td>
  <td>The CLI-friendly name of the service that will appear in the catalog.</td>
</tr>
<tr>
  <td>&nbsp;&nbsp;&nbsp;description*</td>
  <td>string</td>
  <td>A short description of the service that will appear in the catalog.</td>
</tr>
<tr>
  <td>&nbsp;&nbsp;&nbsp;bindable*</td>
  <td>boolean</td>
  <td>Whether the service can be bound to applications.</td>
</tr>
<tr>
  <td>&nbsp;&nbsp;&nbsp;tags</td>
  <td>array-of-strings</td>
  <td>Tags provide a flexible mechanism to expose a classification, attribute, or base technology of a service, enabling equivalent services to be swapped out without changes to dependent logic in applications, buildpacks, or other services. E.g. mysql, relational, redis, key-value, caching, messaging, amqp.</td>
</tr>
<tr>
  <td>&nbsp;&nbsp;&nbsp;metadata</td>
  <td>object</td>
  <td>A list of metadata for a service offering. For more information, see <a href="catalog-metadata.html">Catalog Metadata</a>.</td>
</tr>
<tr>
  <td>&nbsp;&nbsp;&nbsp;requires</td>
  <td>array-of-strings</td>
  <td>A list of permissions that the user would have to give the service, if they provision it. The only permission currently supported is <tt>syslog_drain</tt>; for more info see <a href="app-log-streaming.html">Application Log Streaming</a>.</td>
</tr>
<tr>
  <td>&nbsp;&nbsp;&nbsp;plans*</td>
  <td>array-of-objects
</td>
  <td>A list of plans for this service, schema defined below:</td>
</tr>
<tr>
  <td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;id*</td>
  <td>string</td>
  <td>An identifier used to correlate this plan in future requests to the catalog. This must be unique within Cloud Foundry, using a GUID is recommended.</td>
</tr>
<tr>
  <td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name*</td>
  <td>string</td>
  <td>The CLI-friendly name of the plan that will appear in the catalog.</td>
</tr>
<tr>
  <td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;description*</td>
  <td>string</td>
  <td>A short description of the service that will appear in the catalog.</td>
</tr>
<tr>
  <td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;metadata</td>
  <td>object</td>
  <td>A list of metadata for a service plan. For more information, see <a href="catalog-metadata.html">Catalog Metadata</a>.</td>
</tr>
</tbody>
</table>

\* Fields with an asterisk are required.

<pre class="terminal">
{
  "services": [{
    "id": "service-guid-here",
    "name": "mysql",
    "description": "A MySQL-compatible relational database",
    "bindable": true,
    "plans": [{
      "id": "plan1-guid-here",
      "name": "small",
      "description": "A small shared database with 100mb storage quota and 10 connections"
    },{
      "id": "plan2-guid-here",
      "name": "large",
      "description": "A large dedicated database with 10GB storage quota, 512MB of RAM, and 100 connections"
    }]
  }]
}
</pre>

### <a id='create-broker'></a>Adding a Broker to Cloud Foundry ###

Once you've implemented the first endpoint `GET /v2/catalog` above, you'll want to [register the broker with CF](managing-service-brokers.html#register-broker) to make your services and plans available to end users.

## <a id='provisioning'></a>Provisioning ##

When the broker receives a provision request from Cloud Controller, it should synchronously take whatever action is necessary to create a new service resource for the developer. The result of provisioning varies by service type, although there are a few common actions that work for many services. For a MySQL service, provisioning could result in:

* An empty dedicated `mysqld` process running on its own VM.
* An empty dedicated `mysqld` process running in a lightweight container on a shared VM.
* An empty dedicated `mysqld` process running on a shared VM.
* An empty dedicated database, on an existing shared running `mysqld`.
* A database with business schema already there.
* A copy of a full database, for example a QA database that is a copy of the production database.

For non-data services, provisioning could just mean getting an account on an existing system.

### Request ###

##### Route #####
`PUT /v2/service_instances/:instance_id`

<p class="note"><strong>Note</strong>: The <code>:instance_id</code> of a service instance is provided by the Cloud Controller. This ID will be used for future requests (bind and deprovision), so the broker must use it to correlate the resource it creates.</p>

##### Body #####

<table border="1" class="nice">
<thead>
<tr>
  <th>Request field</th>
  <th>Type</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td>service_id*</td>
  <td>string</td>
  <td>The ID of the service within the catalog above. While not strictly necessary, some brokers might make use of this ID.</td>
</tr>
<tr>
  <td>plan_id*</td>
  <td>string</td>
  <td>The ID of the plan within the above service (from the catalog endpoint) that the user would like provisioned. Because plans have identifiers unique to a broker, this is enough information to determine what to provision.</td>
</tr>
<tr>
  <td>organization_guid*</td>
  <td>string</td>
  <td>The Cloud Controller GUID of the organization under which the service is to be provisioned. Although most brokers will not use this field, it could be helpful in determining data placement or applying custom business rules.</td>
</tr>
<tr>
  <td>space_guid*</td>
  <td>string</td>
  <td>Similar to organization_guid, but for the space.</td>
</tr>
</tbody>
</table>

### Response ###

<table border="1" class="nice">
<thead>
<tr>
  <th>Status Code</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td>201 Created</td>
  <td>Service instance has been created. The expected response body is below.</td>
</tr>
<tr>
  <td>200 OK</td>
  <td>
    May be returned if the service instance already exists and the requested parameters are identical to the existing service instance.
    The expected response body is below.
  </td>
</tr>
<tr>
  <td>409 Conflict</td>
  <td>Should be returned if the requested service instance already exists. The expected response body is "{}", though the description field can be used to return a user-facing error message, as described in <a href="#broker-errors">Broker Errors</a>.</td>
</tr>
</tbody>
</table>

Responses with any other status code will be interpreted as a failure. Brokers can include a user-facing message in the `description` field; for details see [Broker Errors](#broker-errors).

##### Body #####

All response bodies must be a valid JSON Object (`{}`). This is for future compatibility; it will be easier to add fields in the future if JSON is expected rather than to support the cases when a JSON body may or may not be returned.

For success responses, the following fields are valid.

<table border="1" class="nice">
<thead>
<tr>
  <th>Response field</th>
  <th>Type</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td>dashboard_url</td>
  <td>string</td>
  <td>The URL of a web-based management user interface for the service instance; we refer to this as a service dashboard. The URL should contain enough information for the dashboard to identify the resource being accessed ("9189kdfsk0vfnku" in the example below). For information on how users can authenticate with service dashboards via SSO, see <a href="dashboard-sso.html">Dashboard Single Sign-On</a>.</td>
</tr>
</tboby>
</table>

<pre class="terminal">
{
 "dashboard_url": "http://mongomgmthost/databases/9189kdfsk0vfnku"
}
</pre>

## <a id='binding'></a>Binding ##

<p class="note"><strong>Note</strong>: Not all services must be bindable --- some deliver value just from being provisioned. Brokers that offer services that are not bindable should declare them as such using `bindable: false` in the [Catalog](#catalog-mgmt). Brokers that do not offer any bindable services do not need to implement the endpoint for bind requests.</p>

When the broker receives a bind request from the Cloud Controller, it should return information which helps an application to utilize the provisioned resource. This information is generically referred to as `credentials`. Applications should be issued unique credentials whenever possible, so one application's access can be revoked without affecting other bound applications. For more information on credentials, see [Binding Credentials](binding-credentials.html).

In addition, the bind operation can enable streaming of application logs from Cloud Foundry to a consuming service instance. For details, see [Application Log Streaming](app-log-streaming.html).

### Request ###

##### Route #####

`PUT /v2/service_instances/:instance_id/service_bindings/:binding_id`

<p class="note"><strong>Note</strong>: The <code>:binding_id</code> of a service binding is provided by the Cloud Controller. <code>:instance_id</code> is the ID of a previously-provisioned service instance; <code>:binding_id</code> will be used for future unbind requests, so the broker must use it to correlate the resource it creates.</p>

##### Body #####

<table border="1" class="nice">
<thead>
<tr>
  <th>Request Field</th>
  <th>Type</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td>service_id*</td>
  <td>string</td>
  <td>ID of the service from the catalog. While not strictly necessary, some brokers might make use of this ID.</td>
</tr>
<tr>
  <td>plan_id*</td>
  <td>string</td>
  <td>ID of the plan from the catalog. While not strictly necessary, some brokers might make use of this ID.</td>
</tr>
</tbody>
</table>

### Response ###

<table border="1" class="nice">
<thead>
<tr>
  <th>Status Code</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td>201 Created</td>
  <td>Binding has been created. The expected response body is below.</td>
</tr>
<tr>
  <td>200 OK</td>
  <td>
    May be returned if the binding already exists and the requested parameters are identical to the existing binding.
    The expected response body is below.
  </td>
</tr>
<tr>
  <td>409 Conflict</td>
  <td>Should be returned if the requested binding already exists. The expected response body is "{}", though the description field can be used to return a user-facing error message, as described in <a href="#broker-errors">Broker Errors</a>.</td>
</tr>
</tbody>
</table>

Responses with any other status code will be interpreted as a failure and an unbind request will be sent to the broker to prevent an orphan being created on the broker. Brokers can include a user-facing message in the `description` field; for details see [Broker Errors](#broker-errors).

##### Body #####

+All response bodies must be a valid JSON Object (`{}`). This is for future compatibility; it will be easier to add fields in the future if JSON is expected rather than to support the cases when a JSON body may or may not be returned.
+
+For success responses, the following fields are valid.

<table border="1" class="nice">
<thead>
<tr>
  <th>Response Field</th>
  <th>Type</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td>credentials</td>
  <td>object</td>
  <td>A free-form hash of credentials that the bound application can use to access the service. For more information, see <a href="binding-credentials.html">Binding Credentials</a>.</td>
</tr>
<tr>
  <td>syslog_drain_url</td>
  <td>string</td>
  <td>A URL to which Cloud Foundry should drain logs for the bound application. <code>requires:syslog_drain</code> must be declared in the <a href="#catalog-mgmt">catalog endpoint</a> or Cloud Foundry will consider the response invalid. For details, see <a href="app-log-streaming.html">Application Log Streaming</a>.</td>
</tr>
</tbody>
</table>

<pre class="terminal">
    {
      "credentials": {
        "uri": "mysql://mysqluser:pass@mysqlhost:3306/dbname",
        "username": "mysqluser",
        "password": "pass",
        "host": "mysqlhost",
        "port": 3306,
        "database": "dbname"
      }
    }
</pre>

## <a id='unbinding'></a>Unbinding ##

<p class="note"><strong>Note</strong>: Brokers that do not provide any bindable services do not need to implement the endpoint for unbind requests.</p>

When a broker receives an unbind request from Cloud Controller, it should delete any resources it created in bind. Usually this means that an application immediately cannot access the resource.

### Request ###

##### Route #####

`DELETE /v2/service_instances/:instance_id/service_bindings/:binding_id`

The `:binding_id` in the URL is the identifier of a previously created binding (the same `:binding_id` passed in the bind request). The request has no body, because DELETE requests generally do not have bodies.

##### Parameters #####

The request provides these query string parameters as useful hints for brokers.

<table border="1" class="nice">
<thead>
<tr>
  <th>Query-String Field</th>
  <th>Type</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td>service_id*</td>
  <td>string</td>
  <td>ID of the service from the catalog. While not strictly necessary, some brokers might make use of this ID.</td>
</tr>
<tr>
  <td>plan_id*</td>
  <td>string</td>
  <td>ID of the plan from the catalog. While not strictly necessary, some brokers might make use of this ID.</td>
</tr>
</tbody>
</table>

### Response ###

<table border="1" class="nice">
<thead>
<tr>
  <th>Status Code</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td>200 OK</td>
  <td>Binding was deleted. The expected response body is "{}"</td>
</tr>
<tr>
  <td>410 Gone</td>
  <td>Should be returned if the binding does not exist. The expected response body is "{}"</td>
</tr>
</tbody>
</table>

Responses with any other status code will be interpreted as a failure and the binding will remain in the Cloud Controller database. Brokers can include a user-facing message in the `description` field; for details see [Broker Errors](#broker-errors).

##### Body #####

All response bodies must be a valid JSON Object (`{}`). This is for future compatibility; it will be easier to add fields in the future if JSON is expected rather than to support the cases when a JSON body may or may not be returned.

For a success response, the expected response body is `"{}"`.

## <a id='deprovisioning'></a>Deprovisioning ##

When a broker receives a deprovision request from Cloud Controller, it should delete any resources it created during the provision. Usually this means that all resources are immediately reclaimed for future provisions.

### Request ###

##### Route #####

`DELETE /v2/service_instances/:instance_id`

The `:instance_id` in the URL is the identifier of a previously provisioned instance (the same `:instance_id` passed in the provision request).  The request has **no body**, because DELETE requests generally do not have bodies.

##### Parameters #####

The request provides these query string parameters as useful hints for brokers.

<table border="1" class="nice">
<thead>
<tr>
  <th>Query-String Field</th>
  <th>Type</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td>service_id*</td>
  <td>string</td>
  <td>ID of the service from the catalog. While not strictly necessary, some brokers might make use of this ID.</td>
</tr>
<tr>
  <td>plan_id*</td>
  <td>string</td>
  <td>ID of the plan from the catalog. While not strictly necessary, some brokers might make use of this ID.</td>
</tr>
</tbody>
</table>

### Response ###

<table border="1" class="nice">
<thead>
<tr>
  <th>Status Code</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td>200 OK</td>
  <td>Service instance was deleted. The expected response body is "{}"</td>
</tr>
<tr>
  <td>410 Gone</td>
  <td>Should be returned if the service instance does not exist. The expected response body is "{}"</td>
</tr>
</tbody>
</table>

Responses with any other status code will be interpreted as a failure and the service instance will remain in the Cloud Controller database. Brokers can include a user-facing message in the `description` field; for details see [Broker Errors](#broker-errors).

##### Body #####

All response bodies must be a valid JSON Object (`{}`). This is for future compatibility; it will be easier to add fields in the future if JSON is expected rather than to support the cases when a JSON body may or may not be returned.

For a success response, the expected response body is `"{}"`.

## <a id='broker-errors'></a>Broker Errors ##

### Response ###

When a broker fails to perform any requested operation, unless it fails with a well-defined HTTP response code listed above (like 410 on delete), it should return an appropriate HTTP response code (chosen to accurately reflect the nature of the failure) and a body containing a JSON Object (not an array).

##### Body #####

All response bodies must be a valid JSON Object (`{}`). This is for future compatibility; it will be easier to add fields in the future if JSON is expected rather than to support the cases when a JSON body may or may not be returned.

For error responses, the following fields are valid. If empty JSON is returned in the body `"{}"`, a generic message containing the HTTP response code returned by the broker will be displayed to the requestor.

<table border="1" class="nice">
<thead>
<tr>
  <th>Response Field</th>
  <th>Type</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td>description</td>
  <td>string</td>
  <td>An error message explaining why the request failed. This message will be displayed to the user who initiated the request.</td>
</tr>
</tbody>
</table>

<pre class="terminal">
{
  "description": "Something went wrong. Please contact support at http://support.example.com."
}
</pre>

## <a id='orphans'></a>Orphans ##

The Cloud Controller and Broker are expected to store identical copies of existing instances and bindings. These two lists can potentially become inconsistent if the broker doesn't return a response before the request times out (typically 60 seconds). For example, if a broker doesn't return a response to a provision request before Cloud Controller times out, the broker may eventually succeed where Cloud Controller considered this a failure. This results in an orphan instance on the service side.
